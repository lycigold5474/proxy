# 프록시 예제 3가지

* v1 - 인터페이스와 구현클래스 - 스프링 빈으로 수동등록
* v2 - 인터페이스 없는 구체클래스 - 스프링 빈으로 수동등록
* v3 - 컴포넌트 스캔으로 스프링 빈 자동 등록

### v1 - 인터페이스와 구현클래스 - 스프링 빈으로 수동등록

### v2 - 인터페이스 없는 구체클래스 - 스프링 빈으로 수동등록

### v3 - 컴포넌트 스캔으로 스프링 빈 자동 등록

### 요구사항 추가

* 원본코드를 수정하지 않고, 로그추적기를 적용
* 특정메서드는 로그를 출력하지 않는 기능
    * 보안상 일부는 로그를 출력하면 안됨
* 다음의 다양한 케이스에 적용 할 수 있어야함 
    * v1- 인터페이스가 있는 구현 클래스에 적용
    * v2- 인터페이스가 없는 구체 클레스에 적용
    * v3- 컴포넌트 스캔 대상에 기능 적용

### 프록시, 프록시 패턴, 데코레이터 패턴 소개

* 프록시 : 클라이언트가 요청한 결과를 서버에 대리자를 통해 간접적으로 서버에 요청, 대리자를 프록시
* 프록시체인 : 대리자에게 요청한 것을 또다른 대리자에게 요청한것 

* 프록시 패턴의도 : 다른개체에 대한 접근을 제어하기 위해 대리자를 제공
* 데코레이터 패턴의도 : 객체에 추가 책임을 동적으로 추가하고 기능확장을 위한 유연한 대안 제공

* 접근제어가 목적이라면 프로식패턴, 새로운기능을 추가하는 것이 목적이라면 데코레이터 패턴

### 인터페이스 기반 프록시와 클래스 기반 프록시

* 인터페이스가 없어도 클래스기반으로 프록시 생성 가능
* 클래스기반 클래스는 해당클래스만 적용 할 수 있고, 인터페이스 기반 프록시는 인터페이스만 같으면 모든 곳에 적용 할 수 있음
* 클래스기반 클래스는 상속을 사용을 사용하기때문에 몇가지 제약사항이 있음
  * 부모클래스의 생성자를 호출해야함
  * 클래스에 final키워드가 붙으면 상속이 불가능함
  * 메서드에 final키워드가 붙으면 해당메서드를 오버라이딩 할 수 없음

* 실무에서 인터페이스가 있는 경우와 구체클래가 있는 경우에 상황에 따라 대응
* 프록시 코드들이 너무많음 => 프록시 클래스를 하나 만들어서 모든 곳에 적용가능할까? 

### 프록시 팩토리

* 프록시 팩토리와 어드바이저로 프록시를 이용하여 원본코드를 수정하지 않고 적용하고, 포인트컷으로 어디에 부가기능에 적용할지 명확하게 정의 할 수 있음
* 단점으로 설정파일이 너무많음 각 스프링 빈마다 설정코드를 생성해야함
* 컴포넌트 스캔으로 사용한경우 현재까지 방법으로 프록시 적용이 불가능함
  * 실제객체를 스프링 빈으로 바로 등록해버리기때문에 프록시를 등록할 틈이 없음

### 빈 후처리기

* 빈저장소에 등록하기 직전에 조작하고 싶을때 빈 후처리기를 사용 
* BeanPostProcessor
* 객체 조작 또는 교체도 가능함